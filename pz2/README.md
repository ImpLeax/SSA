# Практична робота 2 

## Завдання 1

Для цього завдання потрібно написати програму мовою C для дослідження типу даних `time_t` на різних архітектурах (32-bit та 64-bit). Мета роботи — продемонструвати "Проблему 2038 року" та проаналізувати сегменти виконуваного файлу в середовищі Linux (WSL/Ubuntu).

## Опис завдання

Програма визначає розмір `time_t` у байтах та бітах. В залежності від архітектури, під яку скомпільовано файл:

* **32-bit:** Демонструє переповнення часу після 19 січня 2038 року.
* **64-bit:** Демонструє безпеку та значно більший діапазон часу.

## 1. Стандартна компіляція (64-bit)

За замовчуванням на сучасних системах GCC створює 64-бітний виконуваний файл.

```bash
gcc -Wall zd1.c -o prog_64_bit
./prog_64_bit

```
Фрагмент коду із обробкою для 64-бітної версії:

```C
    else if (sizeof(time_t) == 8) {
        printf("Architecture: 64-bit (safe from Year 2038 problem)\n");
        
        time_t max_time = 0x7FFFFFFFFFFFFFFF;
        printf("Current system time: %s\n", ctime(&max_time));
        
        printf("Theoretical limit is approx. 292 billion years from now.\n");
    }
```

## Вивід:
```bash
Size of time_t: 8 bytes (64 bits)
Architecture: 64-bit (safe from Year 2038 problem)
Current system time: (null)
Theoretical limit is approx. 292 billion years from now.
```

Виводить `null` тому що максимальне значення `time_t` це мільярди років і `ctime` не може це обробити.

### 2. Компіляція для 32-bit (режим сумісності)

Для емуляції старої архітектури використовується прапорець `-m32`.

```bash
gcc -m32 -Wall zd1.c -o prog_32_bit
```

Після першої компіляції 32-бітної версії виникає помилка:

```bash
In file included from zd1.c:1:
/usr/include/stdio.h:28:10: fatal error: bits/libc-header-start.h: No such file or directory
   28 | #include <bits/libc-header-start.h>
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
```

### Причина

У стандартній установці Ubuntu/WSL відсутні бібліотеки розробки (`libc6-dev-i386`) та заголовкові файли, необхідні для створення 32-бітних програм.

Для вирішення цієї проблеми потрібно встановити пакет `gcc-multilib`, після чого компіляція та запуск програми проходить без проблем.

Фрагмент коду із обробкою для 32-бітної версії:

```C
    if (sizeof(time_t) == 4) {
        printf("Architecture: 32-bit (vulnerable to Year 2038 problem)\n");

        time_t max_time = 0x7FFFFFFF; 
        printf("Maximum reachable time: %s\n", ctime(&max_time));
        
        max_time++; 
        printf("After overflow (+1 sec): %s\n", ctime(&max_time));
        printf("Note: The clock wrapped around to December 1901.\n");
    } 
```

```bash
sudo apt install gcc-multilib
gcc -m32 zd1.c -o prog_32_bit
./prog_32_bit
Size of time_t: 4 bytes (32 bits)
Architecture: 32-bit (vulnerable to Year 2038 problem)
Maximum reachable time: Tue Jan 19 03:14:07 2038

After overflow (+1 sec): Fri Dec 13 20:45:52 1901

Note: The clock wrapped around to December 1901.
```

Після додаваня 1 секунди відбувається переповнення і дата скидується до 1901 року.

### Аналіз розмірів сегментів (результати `size`)

Для дослідження впливу архітектури на структуру виконуваного файлу було використано команду `size`. Отримані результати для 64-бітної та 32-бітної версій програми:

| Сегмент | prog_64_bit (байт) | prog_32_bit (байт) | Різниця |
| --- | --- | --- | --- |
| **text** (код) | 1978 | 1880 | +98 байт |
| **data** (ініц. дані) | 624 | 316 | +308 байт (~2x) |
| **bss** (неініц. дані) | 8 | 4 | +4 байти (2x) |
| **dec** (разом) | 2610 | 2200 | +410 байт |

#### Пояснення змін:

1. **Сегмент Text (Код програми):**
* Розмір у 64-бітній версії трохи більший (1978 проти 1880). Це пов'язано з тим, що інструкції x86-64 можуть бути довшими (через префікси REX), а адреси пам'яті, які "зашиті" в код, займають 8 байт замість 4.


2. **Сегмент Data (Ініціалізовані дані):**
* Спостерігається найбільший ріст (624 проти 316). Це ключовий показник зміни архітектури.
* У 64-бітному режимі всі вказівники (pointers) та типи даних `size_t`, `time_t` (які використовуються у `printf` та глобальних структурах) мають розмір **8 байт**.
* У 32-бітному режимі вони займають лише **4 байти**.
* Також впливає **вирівнювання пам'яті (alignment)**: 64-бітні процесори працюють ефективніше, коли дані вирівняні по межі 8 байт, що додає "порожні" байти (padding) у файл, збільшуючи його розмір.


3. **Сегмент BSS (Неініціалізовані дані):**
* Розмір рівно вдвічі більший (8 проти 4). Це чітко демонструє, що змінна (або службовий вказівник), яка потрапила в цей сегмент, змінила свій розмір з 32 біт (4 байти) на 64 біти (8 байт).

## Повний код: [zd1.c](zd1/zd1.c)

## Завдання 2

Для цього завдання потрібно дослідити розміщення даних у сегментах виконуваного файлу (Text, Data, BSS) за допомогою утиліт `ls -l` (для визначення загального розміру файлу на диску) та `size` (для розмірів сегментів). Мета роботи — на практиці перевірити, як ініціалізація змінних, їх локальність та прапорці компіляції впливають на структуру пам'яті.

## Опис завдання

Програма послідовно модифікується, щоб продемонструвати:

* Вплив глобальних неініціалізованих масивів (BSS).
* Вплив глобальних ініціалізованих масивів (Data).
* Поведінку локальних масивів усередині функцій (Стек).
* Вплив прапорців налагодження (`-g`) та оптимізації (`-O3`) на розміри файлу та сегментів.

---

### 1. Базова програма "Hello World"

Скомпільовано базову програму без додаткових масивів для фіксації початкових розмірів.

```bash
gcc -Wall zd2_1.c -o prog2_1
ls -l prog2_1
size prog2_1

```

**Вивід:**

```bash
-rwxr-xr-x 1 impleax impleax 15960 Feb 19 09:12 prog2_1

   text    data     bss     dec     hex filename
   1381     600       8    1989     7c5 prog2_1

```

*Початкові розміри: загальний файл — 15960 байт, сегмент даних — 600 байт, BSS — 8 байт.*

---

### 2. Додавання глобального неініціалізованого масиву (1000 `int`)

До коду додано масив `int arr[1000];` без ініціалізації.

```bash
gcc -Wall zd2_2.c -o prog2_2
ls -l prog2_2
size prog2_2

```

**Вивід:**

```bash
-rwxr-xr-x 1 impleax impleax 15992 Feb 19 09:15 prog2_2

   text    data     bss     dec     hex filename
   1381     600    4032    6013    177d prog2_2

```

**Різниця:**

* Сегмент **BSS** різко зріс з 8 до 4032 байт (+4024 байти), оскільки масив з 1000 елементів типу `int` (по 4 байти) потребує 4000 байт пам'яті.
* Загальний розмір файлу на диску (`ls -l`) майже не змінився (15960 -> 15992). Це доводить, що BSS не зберігається фізично у файлі.

---

### 3. Ініціалізація глобального масиву

До коду додано початкове значення для масиву, наприклад: `int arr[1000] = {1};`. Це переміщує його з BSS у Data.

```bash
gcc -Wall zd2_3.c -o prog2_3
ls -l prog2_3
size prog2_3

```

**Вивід:**

```bash
-rwxr-xr-x 1 impleax impleax 20008 Feb 19 09:18 prog2_3

   text    data     bss     dec     hex filename
   1381    4616       8    6005    1775 prog2_3

```

**Різниця:**

* Сегмент **BSS** повернувся до 8 байт.
* Сегмент **Data** збільшився з 600 до 4616 байт (+4016 байт).
* Розмір файлу на диску **збільшився** на ~4000 байт (з 15992 до 20008 байт). Це доводить, що сегмент Data фізично зберігається у виконуваному файлі.

---

### 4. Додавання локальних масивів у функцію

У функцію `main` додано великі локальні масиви (ініціалізований та неініціалізований).

```bash
gcc -Wall zd2_4.c -o prog2_4
ls -l prog2_4
size prog2_4

```

**Вивід:**

```bash
-rwxr-xr-x 1 impleax impleax 20056 Feb 19 09:24 prog2_4

   text    data     bss     dec     hex filename
   1624    4624       8    6256    1870 prog2_4

```

**Різниця:**

* Сегменти **Data** та **BSS** практично не змінилися. Локальні масиви не зберігаються в цих сегментах (вони створюються в Стеку під час виконання).
* Сегмент **Text** (код) збільшився з 1381 до 1624 байт, оскільки компілятору довелося додати машинні інструкції для виділення пам'яті та ініціалізації масиву всередині функції під час її виклику.

---

### 5. Компіляція для налагодження (`-g`) та оптимізації (`-O3`)

Проведено компіляцію того ж коду `zd2_4.c` з різними прапорцями.

```bash
gcc -g -Wall zd2_4.c -o prog2_5_debug
gcc -O3 -Wall zd2_4.c -o prog2_5_optimize
ls -l prog2_5*
size prog2_5_debug
size prog2_5_optimize

```

**Вивід розмірів файлів (`ls -l`):**

```bash
-rwxr-xr-x 1 impleax impleax 21384 Feb 19 09:27 prog2_5_debug
-rwxr-xr-x 1 impleax impleax 20016 Feb 19 09:27 prog2_5_optimize

```

**Вивід `size` для Debug (`-g`):**

```bash
   text    data     bss     dec     hex filename
   1624    4624       8    6256    1870 prog2_5_debug

```

**Вивід `size` для Optimize (`-O3`):**

```bash
   text    data     bss     dec     hex filename
   1427    4616       8    6051    17a3 prog2_5_optimize

```

---

### Висновки до завдання 2

На основі отриманих метрик підтверджено наступні теоретичні положення:

1. **Сегмент даних зберігається у виконуваному файлі:** Після ініціалізації масиву `int[1000]` розмір файлу `prog2_3` на диску збільшився пропорційно об'єму даних (~4 КБ), а сам масив перемістився в сегмент Data.
2. **Сегмент BSS не зберігається у виконуваному файлі:** Створення глобального неініціалізованого масиву збільшило значення BSS на 4000 байт (у виводі `size`), але розмір самого виконуваного файлу `prog2_2` на диску залишився таким самим, як у базової програми.
3. **Локальні змінні не впливають на глобальні сегменти:** Додавання локальних масивів усередину функції не збільшило розміри BSS або Data, оскільки пам'ять під них виділяється динамічно в Стеку. Збільшився лише сегмент Text (інструкції для ініціалізації).
4. **Текстовий сегмент піддається оптимізації:** При використанні прапорця `-O3` компілятор скоротив сегмент Text з 1624 до 1427 байт, оптимізувавши машинний код та видаливши зайві інструкції.
5. **На розмір файлу впливає налагодження, але не на сегменти:** Прапорець `-g` збільшив розмір файлу на диску `prog2_5_debug` до 21384 байт (через додавання символів налагодження DWARF), проте команда `size` показала, що розміри сегментів (Text, Data, BSS) залишилися ідентичними звичайній збірці `prog2_4`.

## Завдання 3 (Дослідження віртуальної пам'яті та стека)

Для цього завдання потрібно було написати програму мовою C, яка виводить адреси пам'яті різних змінних та функцій. Мета роботи — практично дослідити віртуальний адресний простір процесу, визначити розташування сегментів Text, Data, BSS, Heap та Stack, а також довести, що стек зростає "вниз" (до менших адрес).

## Опис завдання

Програма оголошує змінні різних типів (глобальні, локальні, динамічні) і виводить їхні адреси в пам'яті.

* Визначається розташування сегментів коду, даних та купи.
* Фіксується початкова вершина стека у функції `main`.
* Викликається додаткова функція з великим локальним масивом для штучного збільшення стека, після чого фіксується нова адреса його вершини.

---

### 1. Визначення приблизного розташування стека

Спочатку було створено базову програму `test.c` для перевірки вершини стека:

```c
#include <stdio.h>
int main() {
    int i;
    printf("The stack top is near %p\n", &i);
    return 0;
}

```

**Компіляція та вивід:**

```bash
gcc -Wall test.c -o prog3_1
./prog3_1
The stack top is near 0x7ffd9eaf7af4

```

---

### 2. Дослідження всіх сегментів пам'яті та зсуву стека

Далі було написано повну програму `zd3.c`, яка оголошує глобальні, динамічні та локальні змінні для фіксації адрес усіх сегментів. У програмі також реалізовано функцію `grow_stack` із масивом на 10000 елементів типу `int` (приблизно 40 КБ) для зміщення вершини стека.

```bash
gcc -Wall zd3.c -o prog3_2
```

**Запуск та результати (`./prog3_2`):**

```bash
--- Memory Segments Addresses ---
Text segment (main function):  0x58fc2edf023f
Data segment (global_init):    0x58fc2edf3010
BSS segment (global_uninit):   0x58fc2edf3018
Heap segment (malloc):         0x58fc6b2b42a0
The stack top in main is near: 0x7ffe97bd148c
The new stack top is near: 0x7ffe97bc781c

```

---

### Висновки до завдання 3

На основі отриманих адрес пам'яті практично підтверджено теоретичну структуру віртуального адресного простору процесу в Linux:

1. **Розташування сегментів (від найменшої адреси до найбільшої):**
* **Text (Код):** Знаходиться найнижче в пам'яті (`0x58fc2edf023f`).
* **Data та BSS:** Розташовані одразу за сегментом коду (`0x58fc2edf3010` та `0x58fc2edf3018`).
* **Heap (Купа):** Розташовується вище за сегменти даних (`0x58fc6b2b42a0`). Купа динамічно зростає "вгору" до більших адрес.
* **Stack (Стек):** Знаходиться на самому верху віртуальної пам'яті (адреси `0x7ffe...`).


2. **Напрямок зростання стека:**
* Початкова адреса змінної у функції `main` становила `0x7ffe97bd148c`.
* Після виклику додаткової функції та створення масиву на 40 КБ, адреса нової локальної змінної на вершині стека склала `0x7ffe97bc781c`.
* Оскільки нова адреса `0x7ffe97bc781c` **менша** за початкову `0x7ffe97bd148c` (різниця становить `0x9C70` або 40048 байт), експериментально **доведено, що стек у поточній архітектурі зростає "вниз"**, у бік менших адрес пам'яті, назустріч купі.



## Повний код: [zd3.c](zd3/zd3.c)

## Завдання 4 (Дослідження стека процесу за допомогою GDB та gstack)

Для цього завдання було написано програму мовою C, яка виконує серію вкладених викликів функцій і зупиняється за допомогою системного блокуючого виклику `pause()`. Мета роботи — дослідити кадри стека (stack frames) працюючого процесу в режимі реального часу за допомогою налагоджувача GDB та утиліти `gstack`, а також навчитися вирішувати проблеми з доступом до пам'яті процесів у середовищі Linux/WSL.

### Опис завдання

1. Створено програму з графом викликів: `main()` -> `foo()` -> `bar()` -> `bar_is_now_closed()` -> `pause()`.
2. Програму скомпільовано з налагоджувальною інформацією (прапорець `-g`).
3. Виконано підключення до працюючого процесу за його PID через GDB.
4. Проаналізовано стек викликів (backtrace).
5. Виконано аналогічний аналіз за допомогою утиліти `gstack` із вирішенням проблем доступу.

---

### 1. Компіляція та запуск програми

Програму було скомпільовано з прапорцем `-g` (для збереження імен функцій та номерів рядків у бінарному файлі) та запущено:

```bash
gcc -g -Wall zd4.c -o prog4
./prog4

```

**Вивід програми:**

```text
My PID is: 1597
In function                 main; &localvar = 0x7fff90657e24
In function                  foo; &localvar = 0x7fff90657df4
In function                  bar; &localvar = 0x7fff90657dd4
In function    bar_is_now_closed; &localvar = 0x7fff90657db4

 Now blocking on pause()...

```

Програма вивела свій PID (`1597`), адреси локальних змінних, які зменшуються з кожним викликом (підтверджуючи, що стек росте вниз), та заблокувалася на виклику `pause()`.

---

### 2. Аналіз стека через GDB

У новому терміналі було запущено налагоджувач GDB з правами суперкористувача (`sudo`) для підключення до процесу.
*(Примітка: Якщо при першому запуску виникає помилка `gdb: command not found`, налагоджувач необхідно встановити командою `sudo apt install gdb`)*.

```bash
sudo gdb -q -p 1597

```

Після успішного підключення було використано команду `bt` (backtrace) для перегляду поточного стану стека викликів:

```text
(gdb) bt
#0  0x0000735c29efa3d4 in __libc_pause () at ../sysdeps/unix/sysv/linux/pause.c:29
#1  0x000063c087aac244 in bar_is_now_closed () at zd4.c:12
#2  0x000063c087aac2a7 in bar () at zd4.c:18
#3  0x000063c087aac30a in foo () at zd4.c:24
#4  0x000063c087aac38f in main (argc=1, argv=0x7fff90657f58) at zd4.c:31

```

**Розбір результатів `backtrace`:**

* **Кадр #0:** Це "вершина" стека (найнижча адреса пам'яті). Процес наразі зупинений всередині системної бібліотеки `libc` на функції `pause`.
* **Кадри #1 - #3:** Відображають послідовність викликів користувацьких функцій: `bar_is_now_closed`, яку викликала `bar`, яку викликала `foo`.
* **Кадр #4:** Це "дно" стека — точка входу `main()`.

Після аналізу від процесу було відключено налагоджувач командами `detach` та `quit`.

---

### 3. Аналіз стека через gstack: Проблеми та їх вирішення

Після GDB була здійснена спроба отримати стек за допомогою скрипта `gstack`. Під час цього виникло кілька типових для Linux системних помилок, які були успішно вирішені.

**Помилка 1: Блокування доступу до ptrace**

```bash
gstack 1597
ptrace: Inappropriate ioctl for device.

```

* **Причина:** Механізми безпеки ядра Linux (Yama ptrace scope) забороняють звичайному користувачу втручатися в пам'ять працюючого процесу. Необхідні права `root`.

**Помилка 2: Втрата шляху при використанні sudo**

```bash
sudo gstack 1597
sudo: gstack: command not found

```

* **Причина:** При використанні `sudo` система скидає змінну середовища `$PATH` з міркувань безпеки. Оскільки `gstack` часто є просто скриптом-обгорткою, що лежить у специфічній директорії, `sudo` не може його знайти за замовчуванням.

**Вирішення (Успішний запуск):**
Проблему було вирішено шляхом динамічної передачі повного шляху до утиліти за допомогою команди `$(which gstack)`:

```bash
sudo $(which gstack) 1597

```

**Отриманий результат:**

```text
Thread 1 (Thread 0x735c2a1d9740 (LWP 1597) "prog4"):
#0  0x0000735c29efa3d4 in __libc_pause () at ../sysdeps/unix/sysv/linux/pause.c:29
#1  0x000063c087aac244 in bar_is_now_closed () at zd4.c:12
#2  0x000063c087aac2a7 in bar () at zd4.c:18
#3  0x000063c087aac30a in foo () at zd4.c:24
#4  0x000063c087aac38f in main (argc=1, argv=0x7fff90657f58) at zd4.c:31

```

Результат повністю ідентичний виводу `bt` з GDB, що доводить принцип роботи `gstack` як зручної обгортки над налагоджувачем.

---

### ✅ Висновки до завдання 4

1. **Структура стека (LIFO):** Інструменти наочно продемонстрували структуру стека за принципом LIFO. Останній викликаний метод (`pause`) знаходиться на вершині стека, а перший (`main`) — у самому низу.
2. **Налагоджувальна інформація:** Прапорець `-g` є критично важливим для аналізу програм. Завдяки йому GDB та `gstack` показали не лише шістнадцяткові адреси пам'яті, а й імена функцій та точні номери рядків у вихідному файлі `zd4.c`.
3. **Безпека процесів:** Доступ до пам'яті процесу (навіть запущеного тим самим користувачем) суворо контролюється ядром Linux. Для виконання трасування (ptrace) необхідне підвищення привілеїв, а робота зі специфічними скриптами через `sudo` вимагає розуміння роботи змінної `$PATH`.

## Повний код: [zd4.c](zd4/zd4.c)
