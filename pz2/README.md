# Практична робота 2 

## Завдання 1

Для цього завдання потрібно написати програму мовою C для дослідження типу даних `time_t` на різних архітектурах (32-bit та 64-bit). Мета роботи — продемонструвати "Проблему 2038 року" та проаналізувати сегменти виконуваного файлу в середовищі Linux (WSL/Ubuntu).

## Опис завдання

Програма визначає розмір `time_t` у байтах та бітах. В залежності від архітектури, під яку скомпільовано файл:

* **32-bit:** Демонструє переповнення часу після 19 січня 2038 року.
* **64-bit:** Демонструє безпеку та значно більший діапазон часу.

## 1. Стандартна компіляція (64-bit)

За замовчуванням на сучасних системах GCC створює 64-бітний виконуваний файл.

```bash
gcc -Wall zd1.c -o prog_64_bit
./prog_64_bit

```
Фрагмент коду із обробкою для 64-бітної версії:

```C
    else if (sizeof(time_t) == 8) {
        printf("Architecture: 64-bit (safe from Year 2038 problem)\n");
        
        time_t max_time = 0x7FFFFFFFFFFFFFFF;
        printf("Current system time: %s\n", ctime(&max_time));
        
        printf("Theoretical limit is approx. 292 billion years from now.\n");
    }
```

## Вивід:
```bash
Size of time_t: 8 bytes (64 bits)
Architecture: 64-bit (safe from Year 2038 problem)
Current system time: (null)
Theoretical limit is approx. 292 billion years from now.
```

Виводить `null` тому що максимальне значення `time_t` це мільярди років і `ctime` не може це обробити.

### 2. Компіляція для 32-bit (режим сумісності)

Для емуляції старої архітектури використовується прапорець `-m32`.

```bash
gcc -m32 -Wall zd1.c -o prog_32_bit
```

Після першої компіляції 32-бітної версії виникає помилка:

```bash
In file included from zd1.c:1:
/usr/include/stdio.h:28:10: fatal error: bits/libc-header-start.h: No such file or directory
   28 | #include <bits/libc-header-start.h>
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
```

### Причина

У стандартній установці Ubuntu/WSL відсутні бібліотеки розробки (`libc6-dev-i386`) та заголовкові файли, необхідні для створення 32-бітних програм.

Для вирішення цієї проблеми потрібно встановити пакет `gcc-multilib`, після чого компіляція та запуск програми проходить без проблем.

Фрагмент коду із обробкою для 32-бітної версії:

```C
    if (sizeof(time_t) == 4) {
        printf("Architecture: 32-bit (vulnerable to Year 2038 problem)\n");

        time_t max_time = 0x7FFFFFFF; 
        printf("Maximum reachable time: %s\n", ctime(&max_time));
        
        max_time++; 
        printf("After overflow (+1 sec): %s\n", ctime(&max_time));
        printf("Note: The clock wrapped around to December 1901.\n");
    } 
```

```bash
sudo apt install gcc-multilib
gcc -m32 zd1.c -o prog_32_bit
./prog_32_bit
Size of time_t: 4 bytes (32 bits)
Architecture: 32-bit (vulnerable to Year 2038 problem)
Maximum reachable time: Tue Jan 19 03:14:07 2038

After overflow (+1 sec): Fri Dec 13 20:45:52 1901

Note: The clock wrapped around to December 1901.
```

Після додаваня 1 секунди відбувається переповнення і дата скидується до 1901 року.

### Аналіз розмірів сегментів (результати `size`)

Для дослідження впливу архітектури на структуру виконуваного файлу було використано команду `size`. Отримані результати для 64-бітної та 32-бітної версій програми:

| Сегмент | prog_64_bit (байт) | prog_32_bit (байт) | Різниця |
| --- | --- | --- | --- |
| **text** (код) | 1978 | 1880 | +98 байт |
| **data** (ініц. дані) | 624 | 316 | +308 байт (~2x) |
| **bss** (неініц. дані) | 8 | 4 | +4 байти (2x) |
| **dec** (разом) | 2610 | 2200 | +410 байт |

#### Пояснення змін:

1. **Сегмент Text (Код програми):**
* Розмір у 64-бітній версії трохи більший (1978 проти 1880). Це пов'язано з тим, що інструкції x86-64 можуть бути довшими (через префікси REX), а адреси пам'яті, які "зашиті" в код, займають 8 байт замість 4.


2. **Сегмент Data (Ініціалізовані дані):**
* Спостерігається найбільший ріст (624 проти 316). Це ключовий показник зміни архітектури.
* У 64-бітному режимі всі вказівники (pointers) та типи даних `size_t`, `time_t` (які використовуються у `printf` та глобальних структурах) мають розмір **8 байт**.
* У 32-бітному режимі вони займають лише **4 байти**.
* Також впливає **вирівнювання пам'яті (alignment)**: 64-бітні процесори працюють ефективніше, коли дані вирівняні по межі 8 байт, що додає "порожні" байти (padding) у файл, збільшуючи його розмір.


3. **Сегмент BSS (Неініціалізовані дані):**
* Розмір рівно вдвічі більший (8 проти 4). Це чітко демонструє, що змінна (або службовий вказівник), яка потрапила в цей сегмент, змінила свій розмір з 32 біт (4 байти) на 64 біти (8 байт).

## Повний код: [zd1.c](zd1/zd1.c)
